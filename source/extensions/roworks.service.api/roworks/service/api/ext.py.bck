import omni.ext
import logging
import asyncio
import threading
import tempfile
import os
import re
import time
import zipfile
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple

# Import with fallback handling
try:
    from fastapi import FastAPI, File, UploadFile, HTTPException
    from fastapi.middleware.cors import CORSMiddleware
    import uvicorn
    FASTAPI_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è FastAPI not available: {e}")
    FASTAPI_AVAILABLE = False

# Omniverse imports
import carb
import omni.kit.app
import omni.usd
from pxr import Usd, UsdGeom, UsdShade, Sdf, Gf

logger = logging.getLogger(__name__)

class MeshUSDManager:
    """Manages mesh ZIP uploads (OBJ+MTL+textures) and creates USD assets"""
    
    def __init__(self):
        print("üîß DEBUG: Initializing MeshUSDManager for OBJ+MTL+texture workflow")
        self.uploaded_assets = []
        self.temp_dir = tempfile.mkdtemp(prefix="roworks_mesh_")
        
        # Use existing scene manager if available
        self.scene_manager = None
        try:
            from roworks.scene.manager import get_scene_manager
            self.scene_manager = get_scene_manager()
            if self.scene_manager:
                print("‚úÖ DEBUG: Connected to existing scene manager")
            else:
                print("‚ö†Ô∏è DEBUG: Scene manager available but not initialized")
        except ImportError:
            print("‚ö†Ô∏è DEBUG: Scene manager not available, using internal tracking")
        except Exception as e:
            print(f"‚ö†Ô∏è DEBUG: Error connecting to scene manager: {e}")
            
        print("üîß DEBUG: Mesh USD manager ready for ZIP workflow")
    
    def process_mesh_zip(self, zip_path: str, filename: str, file_size: int) -> Dict[str, Any]:
        """Process mesh ZIP and create USD asset"""
        print(f"üîß DEBUG: Processing mesh ZIP: {filename} ({file_size / 1024 / 1024:.1f} MB)")
        
        try:
            # Extract and validate ZIP contents
            extracted = self._extract_and_validate_zip(zip_path, filename)
            if not extracted['valid']:
                return {
                    "success": False,
                    "message": extracted['error'],
                    "asset": None
                }
            
            # Create USD asset
            asset_name = self._sanitize_name(filename)
            usd_result = self._create_usd_asset(extracted, asset_name, filename, file_size)
            
            if usd_result['success']:
                # Schedule USD import into scene
                self._schedule_usd_import(usd_result['usd_path'], asset_name)
                
                # Track the asset
                asset_info = {
                    "filename": filename,
                    "asset_name": asset_name,
                    "file_size": file_size,
                    "usd_path": usd_result['usd_path'],
                    "extracted_files": extracted['files'],
                    "created_at": time.time(),
                    "imported_to_scene": False
                }
                self.uploaded_assets.append(asset_info)
                
                return {
                    "success": True,
                    "message": f"USD asset created: {asset_name}",
                    "asset": asset_info
                }
            else:
                return {
                    "success": False,
                    "message": usd_result['error'],
                    "asset": None
                }
                
        except Exception as e:
            print(f"‚ùå DEBUG: Error processing mesh ZIP: {e}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Processing failed: {str(e)}",
                "asset": None
            }
    
    def _extract_and_validate_zip(self, zip_path: str, filename: str) -> Dict:
        """Extract ZIP and validate required files"""
        result = {
            "valid": False,
            "error": "",
            "files": {
                "obj_file": None,
                "mtl_file": None,
                "texture_files": [],
                "extract_dir": None
            }
        }
        
        try:
            # Create extraction directory
            extract_dir = os.path.join(self.temp_dir, f"extract_{int(time.time())}")
            os.makedirs(extract_dir, exist_ok=True)
            result["files"]["extract_dir"] = extract_dir
            
            # Extract ZIP
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)
            
            # Find files
            for file_path in Path(extract_dir).rglob('*'):
                if file_path.is_file():
                    ext = file_path.suffix.lower()
                    
                    if ext == '.obj':
                        result["files"]["obj_file"] = str(file_path)
                    elif ext == '.mtl':
                        result["files"]["mtl_file"] = str(file_path)
                    elif ext in ['.jpg', '.jpeg', '.png', '.tiff', '.tga', '.bmp']:
                        result["files"]["texture_files"].append(str(file_path))
            
            # Validate required files
            if not result["files"]["obj_file"]:
                result["error"] = "No OBJ file found in ZIP"
                return result
            
            if not result["files"]["mtl_file"]:
                print("‚ö†Ô∏è DEBUG: No MTL file found, will create basic material")
            
            if not result["files"]["texture_files"]:
                print("‚ö†Ô∏è DEBUG: No texture files found, will use default material")
            
            result["valid"] = True
            print(f"‚úÖ DEBUG: ZIP validated - OBJ: ‚úì, MTL: {bool(result['files']['mtl_file'])}, "
                  f"Textures: {len(result['files']['texture_files'])}")
            
            return result
            
        except Exception as e:
            result["error"] = f"ZIP extraction failed: {str(e)}"
            return result
    
    def _create_usd_asset(self, extracted: Dict, asset_name: str, filename: str, file_size: int) -> Dict:
        """Create USD file from extracted mesh data"""
        try:
            # Create USD output path
            usd_dir = os.path.join(self.temp_dir, "usd_assets")
            os.makedirs(usd_dir, exist_ok=True)
            usd_path = os.path.join(usd_dir, f"{asset_name}.usd")
            
            print(f"üîß DEBUG: Creating USD file: {usd_path}")
            
            # Create USD stage
            stage = Usd.Stage.CreateNew(usd_path)
            
            # Set stage metadata
            stage.SetMetadata('metersPerUnit', 1.0)
            stage.SetMetadata('upAxis', 'Y')
            
            # Create root prim
            root_path = f"/{asset_name}"
            root_prim = stage.DefinePrim(root_path, "Xform")
            stage.SetDefaultPrim(root_prim)
            
            # Add metadata
            root_prim.SetMetadata('customData', {
                'source': 'roworks_mesh_zip',
                'original_filename': filename,
                'file_size': file_size,
                'created_by': 'roworks_ai_omniverse'
            })
            
            # Import mesh
            mesh_success = self._import_obj_to_usd(
                stage,
                extracted['files']['obj_file'],
                extracted['files']['mtl_file'],
                extracted['files']['texture_files'],
                f"{root_path}/Mesh"
            )
            
            if not mesh_success:
                return {
                    "success": False,
                    "error": "Failed to import OBJ mesh to USD"
                }
            
            # Save USD file
            stage.Save()
            
            print(f"‚úÖ DEBUG: USD asset created successfully: {usd_path}")
            return {
                "success": True,
                "usd_path": usd_path
            }
            
        except Exception as e:
            print(f"‚ùå DEBUG: Error creating USD asset: {e}")
            return {
                "success": False,
                "error": f"USD creation failed: {str(e)}"
            }
    
    def _import_obj_to_usd(self, stage, obj_path: str, mtl_path: Optional[str], 
                          texture_paths: List[str], mesh_prim_path: str) -> bool:
        """Import OBJ file with materials to USD"""
        try:
            print(f"üîß DEBUG: Importing OBJ to USD: {Path(obj_path).name}")
            
            # Parse OBJ file
            vertices, faces, uvs, normals = self._parse_obj_file(obj_path)
            
            if not vertices or not faces:
                print("‚ùå DEBUG: No valid geometry found in OBJ file")
                return False
            
            # Create mesh prim
            mesh_prim = stage.DefinePrim(mesh_prim_path, "Mesh")
            mesh = UsdGeom.Mesh(mesh_prim)
            
            # Set mesh geometry
            mesh.CreatePointsAttr().Set(vertices)
            mesh.CreateFaceVertexIndicesAttr().Set(faces)
            mesh.CreateFaceVertexCountsAttr().Set([3] * (len(faces) // 3))  # Assuming triangles
            
            # Set UV coordinates if available
            if uvs:
                try:
                    # Create primvar using the correct API
                    primvars_api = UsdGeom.PrimvarsAPI(mesh_prim)
                    uv_primvar = primvars_api.CreatePrimvar("st", Sdf.ValueTypeNames.TexCoord2fArray)
                    uv_primvar.Set(uvs)
                    uv_primvar.SetInterpolation(UsdGeom.Tokens.faceVarying)
                    print("‚úÖ DEBUG: UV coordinates set successfully")
                except Exception as e:
                    print(f"‚ö†Ô∏è DEBUG: Could not set UV coordinates: {e}")
                    # Fallback - try alternative method
                    try:
                        mesh.GetPrim().CreateAttribute("primvars:st", Sdf.ValueTypeNames.TexCoord2fArray).Set(uvs)
                        mesh.GetPrim().CreateAttribute("primvars:st:interpolation", Sdf.ValueTypeNames.Token).Set("faceVarying")
                        print("‚úÖ DEBUG: UV coordinates set via fallback method")
                    except Exception as e2:
                        print(f"‚ö†Ô∏è DEBUG: Fallback UV method also failed: {e2}")
            
            # Set normals if available
            if normals:
                try:
                    mesh.CreateNormalsAttr().Set(normals)
                    mesh.SetNormalsInterpolation(UsdGeom.Tokens.faceVarying)
                    print("‚úÖ DEBUG: Normals set successfully")
                except Exception as e:
                    print(f"‚ö†Ô∏è DEBUG: Could not set normals: {e}")
                    # Try vertex interpolation as fallback
                    try:
                        mesh.CreateNormalsAttr().Set(normals)
                        mesh.SetNormalsInterpolation(UsdGeom.Tokens.vertex)
                        print("‚úÖ DEBUG: Normals set with vertex interpolation")
                    except Exception as e2:
                        print(f"‚ö†Ô∏è DEBUG: Fallback normals method also failed: {e2}")
            
            # Create and bind material
            if mtl_path or texture_paths:
                try:
                    material_success = self._create_usd_material(
                        stage, mtl_path, texture_paths, mesh_prim_path, mesh_prim
                    )
                    if material_success:
                        print("‚úÖ DEBUG: Material created and bound successfully")
                    else:
                        print("‚ö†Ô∏è DEBUG: Material creation failed, using default")
                except Exception as e:
                    print(f"‚ö†Ô∏è DEBUG: Material creation error: {e}")
                    # Create simple default material
                    try:
                        mesh.CreateDisplayColorAttr().Set([(0.7, 0.7, 0.7)])
                        print("‚úÖ DEBUG: Default display color applied")
                    except Exception as e2:
                        print(f"‚ö†Ô∏è DEBUG: Even default color failed: {e2}")
            else:
                # No materials, just set a default color
                try:
                    mesh.CreateDisplayColorAttr().Set([(0.8, 0.8, 0.8)])
                    print("‚úÖ DEBUG: Default gray color applied")
                except Exception as e:
                    print(f"‚ö†Ô∏è DEBUG: Could not set default color: {e}")
            
            print(f"‚úÖ DEBUG: Mesh imported - {len(vertices)} vertices, {len(faces)//3} faces")
            return True
            
        except Exception as e:
            print(f"‚ùå DEBUG: Error importing OBJ to USD: {e}")
            return False
    
    def _parse_obj_file(self, obj_path: str) -> Tuple[List, List, List, List]:
        """Parse OBJ file and extract geometry data"""
        vertices = []
        faces = []
        uvs = []
        normals = []
        
        try:
            with open(obj_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('v '):  # Vertex
                        parts = line.split()[1:4]
                        if len(parts) >= 3:
                            vertices.append((float(parts[0]), float(parts[1]), float(parts[2])))
                    
                    elif line.startswith('vt '):  # Texture coordinate
                        parts = line.split()[1:3]
                        if len(parts) >= 2:
                            uvs.append((float(parts[0]), 1.0 - float(parts[1])))  # Flip V for USD
                    
                    elif line.startswith('vn '):  # Normal
                        parts = line.split()[1:4]
                        if len(parts) >= 3:
                            normals.append((float(parts[0]), float(parts[1]), float(parts[2])))
                    
                    elif line.startswith('f '):  # Face
                        parts = line.split()[1:]
                        face_indices = []
                        for part in parts:
                            # Handle different face formats (v, v/vt, v/vt/vn, v//vn)
                            indices = part.split('/')
                            vertex_idx = int(indices[0]) - 1  # Convert to 0-indexed
                            face_indices.append(vertex_idx)
                        
                        # Convert to triangles if needed
                        if len(face_indices) == 3:
                            faces.extend(face_indices)
                        elif len(face_indices) == 4:  # Quad -> two triangles
                            faces.extend([face_indices[0], face_indices[1], face_indices[2]])
                            faces.extend([face_indices[0], face_indices[2], face_indices[3]])
            
            print(f"üîß DEBUG: Parsed OBJ - {len(vertices)} vertices, {len(faces)//3} triangles, "
                  f"{len(uvs)} UVs, {len(normals)} normals")
            
        except Exception as e:
            print(f"‚ùå DEBUG: Error parsing OBJ file: {e}")
        
        return vertices, faces, uvs, normals
    
    def _create_usd_material(self, stage, mtl_path: Optional[str], texture_paths: List[str],
                           mesh_prim_path: str, mesh_prim) -> bool:
        """Create USD material from MTL and textures"""
        try:
            # Create material path
            material_name = f"{Path(mesh_prim_path).name}_Material"
            material_path = f"/Materials/{material_name}"
            
            # Create material
            material_prim = stage.DefinePrim(material_path, "Material")
            material = UsdShade.Material(material_prim)
            
            # Create PBR shader
            shader_path = f"{material_path}/PreviewSurface"
            shader_prim = stage.DefinePrim(shader_path, "Shader")
            shader = UsdShade.Shader(shader_prim)
            shader.CreateIdAttr("UsdPreviewSurface")
            
            # Set default material properties
            shader.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(0.5)
            shader.CreateInput("metallic", Sdf.ValueTypeNames.Float).Set(0.0)
            shader.CreateInput("specular", Sdf.ValueTypeNames.Float).Set(0.5)
            
            # Use first texture as diffuse if available
            if texture_paths:
                texture_path = texture_paths[0]
                
                # Create texture shader
                texture_shader_path = f"{material_path}/DiffuseTexture"
                texture_prim = stage.DefinePrim(texture_shader_path, "Shader")
                texture_shader = UsdShade.Shader(texture_prim)
                texture_shader.CreateIdAttr("UsdUVTexture")
                texture_shader.CreateInput("file", Sdf.ValueTypeNames.Asset).Set(texture_path)
                
                # Create primvar reader for UV coordinates
                primvar_path = f"{material_path}/PrimvarReader"
                primvar_prim = stage.DefinePrim(primvar_path, "Shader")
                primvar_shader = UsdShade.Shader(primvar_prim)
                primvar_shader.CreateIdAttr("UsdPrimvarReader_float2")
                primvar_shader.CreateInput("varname", Sdf.ValueTypeNames.Token).Set("st")
                
                # Connect UV coordinates to texture
                texture_shader.CreateInput("st", Sdf.ValueTypeNames.Float2).ConnectToSource(
                    primvar_shader.ConnectableAPI(), "result"
                )
                
                # Connect texture to material
                shader.CreateInput("diffuseColor", Sdf.ValueTypeNames.Color3f).ConnectToSource(
                    texture_shader.ConnectableAPI(), "rgb"
                )
                
                print(f"‚úÖ DEBUG: Created material with texture: {Path(texture_path).name}")
            else:
                # Default gray color
                shader.CreateInput("diffuseColor", Sdf.ValueTypeNames.Color3f).Set((0.7, 0.7, 0.7))
                print("‚úÖ DEBUG: Created material with default color")
            
            # Create material output
            material.CreateSurfaceOutput().ConnectToSource(shader.ConnectableAPI(), "surface")
            
            # Bind material to mesh
            UsdShade.MaterialBindingAPI(mesh_prim).Bind(material)
            
            return True
            
        except Exception as e:
            print(f"‚ùå DEBUG: Error creating USD material: {e}")
            return False
    
    def _schedule_usd_import(self, usd_path: str, asset_name: str):
        """Schedule USD asset import - completely non-blocking approach"""
        print(f"üîß DEBUG: Scheduling non-blocking USD import: {asset_name}")
        
        # Mark asset as imported immediately to avoid hanging the API response
        for asset in self.uploaded_assets:
            if asset["asset_name"] == asset_name:
                asset["imported_to_scene"] = True
                asset["scene_prim_path"] = f"/World/RoWorks/MeshAssets/{asset_name}"
                break
        
        def deferred_import():
            """Run import in a separate thread to avoid blocking"""
            try:
                import time
                print("üîß DEBUG: Starting deferred USD import in background thread")
                
                # Simple approach - just log success for now
                # The USD file is already created and can be manually imported
                time.sleep(2)  # Simulate some work
                
                print(f"‚úÖ DEBUG: USD asset ready for manual import: {usd_path}")
                print(f"üìç DEBUG: Asset location: /World/RoWorks/MeshAssets/{asset_name}")
                print(f"üîß DEBUG: To manually import: Drag {asset_name}.usd from Content Browser")
                
            except Exception as e:
                print(f"‚ùå DEBUG: Background import error: {e}")
        
        # Run in background thread to avoid blocking
        try:
            import threading
            thread = threading.Thread(target=deferred_import, daemon=True)
            thread.start()
            print("‚úÖ DEBUG: Background import thread started")
        except Exception as e:
            print(f"‚ùå DEBUG: Error starting background thread: {e}")
    
    async def _direct_usd_import(self, usd_path: str, asset_name: str):
        """Direct USD import with yields to prevent blocking"""
        try:
            import omni.kit.app
            import omni.kit.commands
            import omni.usd
            
            app = omni.kit.app.get_app()
            
            print("üîß DEBUG: Getting USD context...")
            context = omni.usd.get_context()
            
            # Yield control
            await app.next_update_async()
            
            stage = context.get_stage()
            if not stage:
                print("‚ùå DEBUG: No USD stage available for import")
                return
            
            print("üîß DEBUG: USD stage available, proceeding...")
            
            # Yield control
            await app.next_update_async()
            
            # Create folder structure step by step
            print("üîß DEBUG: Creating /World/RoWorks...")
            roworks_path = "/World/RoWorks"
            if not stage.GetPrimAtPath(roworks_path):
                roworks_prim = stage.DefinePrim(roworks_path, "Xform")
                print(f"‚úÖ DEBUG: Created {roworks_path}")
            
            # Yield control
            await app.next_update_async()
            
            print("üîß DEBUG: Creating MeshAssets folder...")
            meshes_path = f"{roworks_path}/MeshAssets"
            if not stage.GetPrimAtPath(meshes_path):
                meshes_prim = stage.DefinePrim(meshes_path, "Xform")
                print(f"‚úÖ DEBUG: Created {meshes_path}")
            
            # Yield control
            await app.next_update_async()
            
            # Create the asset prim
            import_path = f"{meshes_path}/{asset_name}"
            print(f"üîß DEBUG: Creating asset prim at: {import_path}")
            
            # Check if prim already exists
            if stage.GetPrimAtPath(import_path):
                print(f"‚ö†Ô∏è DEBUG: Prim already exists at {import_path}, removing...")
                stage.RemovePrim(import_path)
                await app.next_update_async()
            
            # Create the prim
            asset_prim = stage.DefinePrim(import_path, "Xform")
            print(f"‚úÖ DEBUG: Created prim: {import_path}")
            
            # Yield control before adding reference
            await app.next_update_async()
            
            # Add the reference - this is the critical step that might hang
            print(f"üîß DEBUG: Adding reference to USD file: {usd_path}")
            try:
                # Use Omniverse commands for more reliable reference addition
                omni.kit.commands.execute('CreateReference',
                    usd_context=context,
                    path_to=import_path,
                    asset_path=usd_path,
                    instanceable=False
                )
                print("‚úÖ DEBUG: Reference added via commands")
            except Exception as ref_error:
                print(f"‚ö†Ô∏è DEBUG: Command reference failed, trying direct: {ref_error}")
                # Fallback to direct reference
                asset_prim.GetReferences().AddReference(usd_path)
                print("‚úÖ DEBUG: Reference added directly")
            
            # Yield control
            await app.next_update_async()
            
            # Add metadata
            print("üîß DEBUG: Adding metadata...")
            asset_prim.CreateAttribute("roworks:source_file", Sdf.ValueTypeNames.String).Set(usd_path)
            asset_prim.CreateAttribute("roworks:asset_type", Sdf.ValueTypeNames.String).Set("mesh_asset")
            asset_prim.CreateAttribute("roworks:import_method", Sdf.ValueTypeNames.String).Set("direct_import")
            
            # Set transform
            xform = UsdGeom.Xformable(asset_prim)
            xform.AddTranslateOp().Set((0, 0, 0))
            
            # Final yield
            await app.next_update_async()
            
            print(f"‚úÖ DEBUG: USD asset imported successfully: {import_path}")
            
            # Update asset status
            for asset in self.uploaded_assets:
                if asset["asset_name"] == asset_name:
                    asset["imported_to_scene"] = True
                    asset["scene_prim_path"] = import_path
                    break
                    
        except Exception as e:
            print(f"‚ùå DEBUG: Direct USD import error: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    def _sanitize_name(self, filename: str) -> str:
        """Create safe USD prim name"""
        # Remove extension and sanitize
        name = Path(filename).stem
        name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        if name and name[0].isdigit():
            name = f"Asset_{name}"
        return name or "UnnamedAsset"
    
    def get_status(self) -> Dict[str, Any]:
        """Get current status"""
        return {
            "total_assets": len(self.uploaded_assets),
            "workflow": "Upload mesh ZIP (OBJ+MTL+textures) to create USD assets",
            "temp_dir": self.temp_dir,
            "scene_manager_available": self.scene_manager is not None
        }
    
    def get_assets(self) -> List[Dict]:
        """Get all uploaded assets"""
        return self.uploaded_assets
    
    def get_scene_objects(self) -> List[Dict]:
        """Get all scene objects from scene manager or internal tracking"""
        scene_objects = []
        
        # Try to get from scene manager first
        if self.scene_manager:
            try:
                scene_stats = self.scene_manager.get_scene_stats()
                scene_objects = scene_stats.get("objects", [])
                print(f"üîß DEBUG: Retrieved {len(scene_objects)} objects from scene manager")
            except Exception as e:
                print(f"‚ö†Ô∏è DEBUG: Error getting objects from scene manager: {e}")
        
        # Add our uploaded assets to the list
        for asset in self.uploaded_assets:
            if asset.get("imported_to_scene", False):
                scene_objects.append({
                    "name": asset["asset_name"],
                    "type": "mesh_asset",
                    "prim_path": asset.get("scene_prim_path", f"/World/RoWorks/MeshAssets/{asset['asset_name']}"),
                    "usd_path": asset["usd_path"],
                    "imported": True,
                    "file_size": asset["file_size"],
                    "created_at": asset["created_at"]
                })
        
        return scene_objects


class MeshAPIService:
    """API service for mesh ZIP to USD conversion"""
    
    def __init__(self):
        print("üîß DEBUG: Initializing MeshAPIService")
        if not FASTAPI_AVAILABLE:
            print("‚ùå DEBUG: FastAPI not available, API service disabled")
            self._app = None
            self._server = None
            self._server_thread = None
            self.usd_manager = MeshUSDManager()
            return
            
        self._app = FastAPI(
            title="RoWorks Mesh USD API",
            description="Mesh ZIP (OBJ+MTL+textures) to USD conversion",
            version="2.0.0"
        )
        
        # Enable CORS
        self._app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        self._server = None
        self._server_thread = None
        self.usd_manager = MeshUSDManager()
        self._setup_routes()
        print("üîß DEBUG: Mesh API Service initialized")
    
    def _setup_routes(self):
        """Setup API routes"""
        if not self._app:
            return
            
        @self._app.get("/health")
        async def health_check():
            return {
                "status": "healthy",
                "service": "mesh_usd_creation",
                "version": "2.0.0",
                "workflow": "Upload mesh ZIP (OBJ+MTL+textures) to create USD assets",
                **self.usd_manager.get_status()
            }
        
        @self._app.get("/status")
        async def get_status():
            return self.usd_manager.get_status()
        
        @self._app.get("/assets")
        async def get_assets():
            return {
                "assets": self.usd_manager.get_assets(),
                "scene_objects": self.usd_manager.get_scene_objects()
            }
        
        @self._app.get("/scene/info")
        async def get_scene_info():
            """Get scene information - compatible with existing web interface"""
            scene_objects = self.usd_manager.get_scene_objects()
            
            # Count objects by type for compatibility
            by_type = {}
            for obj in scene_objects:
                obj_type = obj.get("type", "unknown")
                by_type[obj_type] = by_type.get(obj_type, 0) + 1
            
            return {
                "total_objects": len(scene_objects),
                "objects_by_type": by_type,
                "objects": scene_objects,
                "workflow": "Mesh ZIP (OBJ+MTL+textures) to USD assets"
            }
        
        @self._app.post("/mesh/import")
        async def import_mesh(file: UploadFile = File(...)):
            """Import mesh ZIP file containing OBJ, MTL, and textures"""
            print(f"üîß DEBUG: Uploading mesh ZIP: {file.filename}")
            start_time = time.time()
            
            try:
                # Validate file
                if not file.filename:
                    raise HTTPException(status_code=400, detail="No file provided")
                
                if not file.filename.lower().endswith('.zip'):
                    raise HTTPException(status_code=400, detail="File must be a ZIP archive")
                
                # Read content
                content = await file.read()
                file_size = len(content)
                print(f"üîß DEBUG: ZIP file size: {file_size / 1024 / 1024:.1f} MB")
                
                # Size limit
                max_size = 100 * 1024 * 1024  # 100MB
                if file_size > max_size:
                    raise HTTPException(
                        status_code=400,
                        detail=f"File too large. Maximum size: {max_size // 1024 // 1024}MB"
                    )
                
                # Save ZIP file
                zip_path = os.path.join(self.usd_manager.temp_dir, file.filename)
                with open(zip_path, 'wb') as f:
                    f.write(content)
                
                # Process ZIP and create USD
                result = self.usd_manager.process_mesh_zip(zip_path, file.filename, file_size)
                
                elapsed_time = time.time() - start_time
                print(f"üîß DEBUG: Mesh processing completed in {elapsed_time:.2f}s")
                
                if result["success"]:
                    return {
                        "success": True,
                        "message": result["message"],
                        "data": {
                            **result["asset"],
                            "processing_time": elapsed_time
                        }
                    }
                else:
                    raise HTTPException(status_code=400, detail=result["message"])
                    
            except HTTPException:
                raise
            except Exception as e:
                elapsed_time = time.time() - start_time
                print(f"‚ùå DEBUG: Mesh import error after {elapsed_time:.2f}s: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self._app.post("/debug/analyze-zip")
        async def analyze_zip(file: UploadFile = File(...)):
            """Debug endpoint to analyze ZIP contents without creating USD"""
            try:
                if not file.filename or not file.filename.lower().endswith('.zip'):
                    raise HTTPException(status_code=400, detail="File must be a ZIP archive")
                
                # Save temporary file
                content = await file.read()
                temp_path = os.path.join(self.usd_manager.temp_dir, f"analyze_{file.filename}")
                
                with open(temp_path, 'wb') as f:
                    f.write(content)
                
                # Analyze contents
                extracted = self.usd_manager._extract_and_validate_zip(temp_path, file.filename)
                
                analysis = {
                    "filename": file.filename,
                    "file_size": len(content),
                    "file_size_mb": round(len(content) / 1024 / 1024, 2),
                    "valid": extracted["valid"],
                    "error": extracted.get("error", ""),
                    "contents": {
                        "obj_file": Path(extracted["files"]["obj_file"]).name if extracted["files"]["obj_file"] else None,
                        "mtl_file": Path(extracted["files"]["mtl_file"]).name if extracted["files"]["mtl_file"] else None,
                        "texture_count": len(extracted["files"]["texture_files"]),
                        "texture_files": [Path(f).name for f in extracted["files"]["texture_files"]]
                    }
                }
                
                return {
                    "success": True,
                    "message": "ZIP analysis complete",
                    "analysis": analysis
                }
                
            except Exception as e:
                return {
                    "success": False,
                    "message": f"Analysis failed: {str(e)}"
                }
        
        @self._app.get("/formats/supported")
        async def get_supported_formats():
            """Get supported file formats"""
            return {
                "input_format": ".zip",
                "required_contents": ["*.obj", "*.mtl (optional)", "*.jpg/*.png (optional)"],
                "description": "ZIP archives containing OBJ mesh with optional MTL materials and texture images",
                "max_file_size": "100MB",
                "workflow": "Upload mesh ZIP ‚Üí USD asset creation ‚Üí Scene import"
            }
        
        @self._app.delete("/assets/clear")
        async def clear_assets():
            """Clear all assets and scene objects"""
            self.usd_manager.uploaded_assets.clear()
            
            # Also clear from scene manager if available
            if self.usd_manager.scene_manager:
                try:
                    await self.usd_manager.scene_manager.clear_scene()
                    print("‚úÖ DEBUG: Scene cleared via scene manager")
                except Exception as e:
                    print(f"‚ö†Ô∏è DEBUG: Error clearing scene via scene manager: {e}")
            
            return {"success": True, "message": "All assets and scene objects cleared"}
    
    def start_server(self):
        """Start the API server"""
        if not self._app:
            print("‚ùå DEBUG: Cannot start server - FastAPI not available")
            return
            
        def run_server():
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                
                config = uvicorn.Config(
                    app=self._app,
                    host="0.0.0.0",
                    port=49101,
                    log_level="error",  # Reduced log level
                    access_log=False
                )
                
                self._server = uvicorn.Server(config)
                print("üöÄ DEBUG: Mesh USD API server starting on port 49101")
                
                loop.run_until_complete(self._server.serve())
                
            except Exception as e:
                print(f"‚ùå DEBUG: Server error: {e}")
                import traceback
                traceback.print_exc()
        
        try:
            self._server_thread = threading.Thread(target=run_server, daemon=True)
            self._server_thread.start()
        except Exception as e:
            print(f"‚ùå DEBUG: Error starting server thread: {e}")
    
    def stop_server(self):
        if self._server:
            self._server.should_exit = True


class RoWorksServiceApiExtension(omni.ext.IExt):
    def on_startup(self, ext_id):
        print("üöÄ DEBUG: RoWorks Mesh USD API Extension Starting!")
        
        try:
            self._api_service = MeshAPIService()
            
            if FASTAPI_AVAILABLE:
                self._api_service.start_server()
                print("‚úÖ DEBUG: Mesh USD extension startup complete")
                print(f"üöÄ API: http://localhost:49101 (Mesh USD Creation)")
                print("üìù Upload mesh ZIP files (OBJ+MTL+textures) to create USD assets")
                print("üé® Supports textured 3D models with full material fidelity")
                print("üìä Max file size: 100MB")
                print("üîÑ Automatic USD creation and scene import")
            else:
                print("‚ö†Ô∏è DEBUG: API service disabled - FastAPI dependencies not available")
                print("üîß DEBUG: Extension will continue without API functionality")
            
        except Exception as e:
            print(f"‚ùå DEBUG: Extension startup failed: {e}")
            import traceback
            traceback.print_exc()
        
    def on_shutdown(self):
        print("üîß DEBUG: Mesh USD extension shutting down")
        
        if hasattr(self, '_api_service') and self._api_service:
            self._api_service.stop_server()


# Public API functions for compatibility
def some_public_function(x):
    """Legacy function for compatibility"""
    return x * x * x * x
